export const description = 'Documentation on contestation mechanism of Arbius'

# Contestations

Contestations represent arguments over the validity of proposed solutions

## The Contestation Model

A contestation is a challenge to a potentially invalid solution. It tracks the disputed task, the voting process, and all data needed to resolve whether the solution should be accepted or rejected.

### Properties

<Properties>
  <Property name="validator" type="address">
    Validator that provided solution
  </Property>
  <Property name="blocktime" type="uint64">
    Unix timestamp of solution submission.
  </Property>
  <Property name="finish_start_index" type="uint32">
    What index position to start iteration at for dispersement of value from contestation
  </Property>
  <Property name="slashAmount" type="uint256">
    Amount to slash from losing voters (V6+)
  </Property>
</Properties>

---

## Master Contester System (V6+)

<Note>**V6 introduces master contesters** - a curated group of trusted validators who can initiate contestations. This provides an additional security layer for the network.</Note>

### What are Master Contesters?

Master contesters are authorized validators who:
- Can initiate contestations on suspicious solutions
- Receive +50 vote weight (configurable via `masterContesterVoteAdder`)
- Must maintain minimum validator stake requirements
- Are managed through the Master Contester Registry contract

### Why Master Contesters?

The master contester system provides:
- **Rapid response** to invalid solutions
- **Quality protection** for model reputation and token value
- **Specialized expertise** in detecting fraud
- **Community oversight** through the suggestion mechanism

Anyone can suggest a contestation via `suggestContestation()`, but only master contesters can officially initiate them.
 
---

## Retrieve contestation {{ tag: 'READ', label: 'Engine' }}

<Row>
  <Col>
    Look up a contestation given a `taskid`.
  </Col>
  <Col sticky>

    <CodeGroup title="Request" tag="CALL" label="Engine">

    ```js {{ title: 'ethers' }}
    import { ethers } from 'ethers'
    import Config from './config.json'
    import EngineArtifact from './artifacts/EngineV1.sol/EngineV1.json';

    const provider = new ethers.providers.JsonRpcProvider(RPC_URL);

    const engine = new ethers.Contract(
      Config.engineAddress,
      EngineArtifact.abi,
      provider,
    )
    const contestation = await engine.contestations(taskId);
    const { validator, blocktime, finish_start_index } = contestation;
    ```

    ```solidity {{ title: 'solidity' }}
    pragma solidity ^0.8.13;
    import "./IArbius.sol";

    contract LookupContestationValidator {
        IArbius arbius;

        constructor(IArbius _arbius) {
            arbius = _arbius;
        }

        function lookupContestationValidator(bytes32 taskid)
            public
            view
            returns (address)
        {
            IArbius.Contestation memory t = arbius.contestations(taskid);
            return t.validator;
        }
    }
    ```

    </CodeGroup>

  </Col>
</Row>

---

## Suggest contestation (V6+) {{ tag: 'WRITE', label: 'Engine' }}

<Row>
  <Col>
    <Note>**New in V6**: Anyone can suggest a contestation to alert master contesters of a potentially invalid solution.</Note>

    This function doesn't create an actual contestation - it only emits an event that master contesters can monitor. This allows the community to participate in quality control without requiring master contester privileges.

    Suggested contestations must meet the same timing requirements as regular contestations (before `minClaimSolutionTime` expires).
  </Col>
  <Col sticky>

    <CodeGroup title="Request" tag="WRITE" label="Engine">

    ```js {{ title: 'ethers' }}
    import { ethers } from 'ethers'
    import Config from './config.json'
    import EngineArtifact from './artifacts/V2_EngineV6.sol/V2_EngineV6.json';

    const provider = new ethers.providers.JsonRpcProvider(RPC_URL);

    const wallet = new ethers.Wallet(
      process.env.PRIVATE_KEY,
      provider,
    );

    const engine = new ethers.Contract(
      Config.engineAddress,
      EngineArtifact.abi,
      wallet,
    )

    const taskid = 'task id to suggest contestation for'

    const tx = await engine.suggestContestation(taskid)
    const receipt = await tx.wait()

    // Listen for ContestationSuggested event
    ```

    ```solidity {{ title: 'solidity' }}
    pragma solidity ^0.8.13;
    import "./IArbiusV6.sol";

    contract SuggestContestation {
        IArbiusV6 arbius;

        constructor(IArbiusV6 _arbius) {
            arbius = _arbius;
        }

        function suggestContestation(bytes32 _taskid) public {
            arbius.suggestContestation(_taskid);
        }
    }
    ```

    </CodeGroup>

  </Col>
</Row>

---

## Submit contestation (Master Contesters Only - V6+) {{ tag: 'WRITE', label: 'Engine' }}

<Row>
  <Col>
    <Note>**V6 Change**: Only master contesters can submit contestations. Regular validators should use `suggestContestation()` instead.</Note>

    A contestation may be submitted when a master contester detects a submitted solution to a task is invalid.

    Contestations freeze the claiming process for a solution, and initiate a binary vote. The master contester receives a vote weight bonus (default +50 votes) to help ensure quick resolution.

    Whichever side loses, each forfeits the current `slashAmount`. This is distributed to the winners, in which the first voter (the original solver or contestor) receives 50% of the rewards, with the other winning voters receiving equal shares of the remaining slashed funds.

    If the contestor wins, the task submitter is refunded their fee they paid.

    If the contestor loses, the original solver automatically collects their normal fee and reward.

    Internally, submitting adds you as a vote for, and the original submitter against, the contestation.

    **Requirements:**
    - Must be registered as a master contester
    - Must maintain minimum validator stake
  </Col>
  <Col sticky>

    <CodeGroup title="Request" tag="WRITE" label="Engine">

    ```js {{ title: 'ethers' }}
    import { ethers } from 'ethers'
    import Config from './config.json'
    import EngineArtifact from './artifacts/V2_EngineV6.sol/V2_EngineV6.json';

    const provider = new ethers.providers.JsonRpcProvider(RPC_URL);

    const wallet = new ethers.Wallet(
      process.env.PRIVATE_KEY,
      provider,
    );

    const engine = new ethers.Contract(
      Config.engineAddress,
      EngineArtifact.abi,
      wallet,
    )

    const taskid = 'task id we are contesting'

    // Only works if wallet is a master contester
    const tx = await engine.submitContestation(taskid)
    const receipt = await tx.wait()
    ```

    ```solidity {{ title: 'solidity' }}
    pragma solidity ^0.8.13;
    import "./IArbiusV6.sol";

    contract SubmitContestation {
        IArbiusV6 arbius;

        constructor(IArbiusV6 _arbius) {
            arbius = _arbius;
        }

        function submitContestation(bytes32 _taskid) public {
            // Requires msg.sender to be a master contester
            arbius.submitContestation(_taskid);
        }
    }
    ```

    </CodeGroup>

  </Col>
</Row>

---

## Vote on contestation {{ tag: 'WRITE', label: 'Engine' }}

<Row>
  <Col>
    Validators may vote on whether or not they agree with a contestation within `CONTESTATION_VOTE_PERIOD_TIME`. This will lock `slashAmount` of your staked tokens until the vote is finished. If you win, you will receive these back in staked balance.
  </Col>
  <Col sticky>

    <CodeGroup title="Request" tag="CALL" label="Engine">

    ```js {{ title: 'ethers' }}
    import { ethers } from 'ethers'
    import Config from './config.json'
    import EngineArtifact from './artifacts/EngineV1.sol/EngineV1.json';

    const provider = new ethers.providers.JsonRpcProvider(RPC_URL);

    const wallet = new ethers.Wallet(
      process.env.PRIVATE_KEY,
      provider,
    );

    const engine = new ethers.Contract(
      Config.engineAddress,
      EngineArtifact.abi,
      wallet,
    )

    const taskid = 'task id to contest'
    const agreeWithContest = true;
    const tx = await engine.voteOnContestation(taskid, agreeWithContest);
    const receipt = await tx.wait();
    ```

    ```solidity {{ title: 'solidity' }}
    pragma solidity ^0.8.13;
    import "./IArbius.sol";

    contract VoteOnContestation {
        IArbius arbius;

        constructor(IArbius _arbius) {
            arbius = _arbius;
        }

        function voteOnContestation(
            bytes32 _taskid,
            bool _agree
        ) public {
            arbius.voteOnContestation(_taskid, _agree);
        }
    }
    ```

    </CodeGroup>

  </Col>
</Row>

---

## Finish contestation {{ tag: 'WRITE', label: 'Engine' }}

<Row>
  <Col>
    Once `CONTESTATION_VOTE_PERIOD_TIME` is over, votes are closed, and anyone can finish the contestation. Because the vote information is in a list, you must pass in an `amnt_` for how many rows to process. This will distribute all slashed funds, fees, and restore slashed amounts for winners of the vote.
  </Col>
  <Col sticky>

    <CodeGroup title="Request" tag="CALL" label="Engine">

    ```js {{ title: 'ethers' }}
    import { ethers } from 'ethers'
    import Config from './config.json'
    import EngineArtifact from './artifacts/EngineV1.sol/EngineV1.json';

    const provider = new ethers.providers.JsonRpcProvider(RPC_URL);

    const wallet = new ethers.Wallet(
      process.env.PRIVATE_KEY,
      provider,
    );

    const engine = new ethers.Contract(
      Config.engineAddress,
      EngineArtifact.abi,
      wallet,
    )

    const taskid = 'task id to finish'
    const iterations = 10; // adjust based on votes/pagination
    const tx = await engine.contestationVoteFinish(taskid, iterations);
    const receipt = await tx.wait();
    ```

    ```solidity {{ title: 'solidity' }}
    pragma solidity ^0.8.13;
    import "./IArbius.sol";

    contract FinishContestationVote {
        IArbius arbius;

        constructor(IArbius _arbius) {
            arbius = _arbius;
        }

        function finishVote(
            bytes32 _taskid,
            uint32 _iterations
        ) public {
            arbius.contestationVoteFinish(_taskid, _iterations);
        }
    }
    ```

    </CodeGroup>

  </Col>
</Row>
